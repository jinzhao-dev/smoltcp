From 53c5760a2af9269c85cf153d85f5ab63825f3d72 Mon Sep 17 00:00:00 2001
From: Ruihan Li <lrh2000@pku.edu.cn>
Date: Mon, 4 Nov 2024 10:29:13 +0800
Subject: [PATCH 1/4] Replace all `pub(crate)` with `pub`

This commit is generated from the following command:

	find . -name "*.rs" | xargs sed -i 's|pub(crate)|pub|g'
---
 src/iface/fragmentation.rs       | 40 ++++++++++++++++----------------
 src/iface/interface/ipv4.rs      |  4 ++--
 src/iface/interface/ipv6.rs      |  2 +-
 src/iface/interface/mod.rs       | 20 ++++++++--------
 src/iface/interface/multicast.rs | 10 ++++----
 src/iface/interface/sixlowpan.rs |  2 +-
 src/iface/interface/tcp.rs       |  2 +-
 src/iface/neighbor.rs            | 14 +++++------
 src/iface/packet.rs              | 36 ++++++++++++++--------------
 src/iface/route.rs               |  2 +-
 src/iface/rpl/of0.rs             |  2 +-
 src/iface/rpl/parents.rs         | 16 ++++++-------
 src/iface/rpl/trickle.rs         | 22 +++++++++---------
 src/iface/socket_meta.rs         | 12 +++++-----
 src/iface/socket_set.rs          | 10 ++++----
 src/phy/loopback.rs              |  2 +-
 src/rand.rs                      | 10 ++++----
 src/socket/dhcpv4.rs             | 12 +++++-----
 src/socket/dns.rs                |  8 +++----
 src/socket/icmp.rs               | 12 +++++-----
 src/socket/mod.rs                |  6 ++---
 src/socket/raw.rs                |  8 +++----
 src/socket/tcp.rs                | 12 +++++-----
 src/socket/udp.rs                |  8 +++----
 src/storage/packet_buffer.rs     |  2 +-
 src/tests.rs                     |  6 ++---
 src/wire/dhcpv4.rs               |  2 +-
 src/wire/ip.rs                   |  4 ++--
 src/wire/ipv4.rs                 | 14 +++++------
 src/wire/ipv6.rs                 | 16 ++++++-------
 src/wire/mod.rs                  | 20 ++++++++--------
 src/wire/sixlowpan/frag.rs       |  8 +++----
 src/wire/sixlowpan/nhc.rs        |  4 ++--
 src/wire/udp.rs                  |  2 +-
 34 files changed, 175 insertions(+), 175 deletions(-)

diff --git a/src/iface/fragmentation.rs b/src/iface/fragmentation.rs
index 16c84f4..37f8b67 100644
--- a/src/iface/fragmentation.rs
+++ b/src/iface/fragmentation.rs
@@ -76,7 +76,7 @@ impl<K> PacketAssembler<K> {
         }
     }
 
-    pub(crate) fn reset(&mut self) {
+    pub fn reset(&mut self) {
         self.key = None;
         self.assembler.clear();
         self.total_size = None;
@@ -84,7 +84,7 @@ impl<K> PacketAssembler<K> {
     }
 
     /// Set the total size of the packet assembler.
-    pub(crate) fn set_total_size(&mut self, size: usize) -> Result<(), AssemblerError> {
+    pub fn set_total_size(&mut self, size: usize) -> Result<(), AssemblerError> {
         if let Some(old_size) = self.total_size {
             if old_size != size {
                 return Err(AssemblerError);
@@ -106,11 +106,11 @@ impl<K> PacketAssembler<K> {
     }
 
     /// Return the instant when the assembler expires.
-    pub(crate) fn expires_at(&self) -> Instant {
+    pub fn expires_at(&self) -> Instant {
         self.expires_at
     }
 
-    pub(crate) fn add_with(
+    pub fn add_with(
         &mut self,
         offset: usize,
         f: impl Fn(&mut [u8]) -> Result<usize, AssemblerError>,
@@ -138,7 +138,7 @@ impl<K> PacketAssembler<K> {
     ///
     /// - Returns [`Error::PacketAssemblerBufferTooSmall`] when trying to add data into the buffer at a non-existing
     ///   place.
-    pub(crate) fn add(&mut self, data: &[u8], offset: usize) -> Result<(), AssemblerError> {
+    pub fn add(&mut self, data: &[u8], offset: usize) -> Result<(), AssemblerError> {
         #[cfg(not(feature = "alloc"))]
         if self.buffer.len() < offset + data.len() {
             return Err(AssemblerError);
@@ -164,7 +164,7 @@ impl<K> PacketAssembler<K> {
 
     /// Get an immutable slice of the underlying packet data, if reassembly complete.
     /// This will mark the assembler as empty, so that it can be reused.
-    pub(crate) fn assemble(&mut self) -> Option<&'_ [u8]> {
+    pub fn assemble(&mut self) -> Option<&'_ [u8]> {
         if !self.is_complete() {
             return None;
         }
@@ -176,7 +176,7 @@ impl<K> PacketAssembler<K> {
     }
 
     /// Returns `true` when all fragments have been received, otherwise `false`.
-    pub(crate) fn is_complete(&self) -> bool {
+    pub fn is_complete(&self) -> bool {
         self.total_size == Some(self.assembler.peek_front())
     }
 
@@ -207,7 +207,7 @@ impl<K: Eq + Copy> PacketAssemblerSet<K> {
     /// If it doesn't exist, it is created, with the `expires_at` timestamp.
     ///
     /// If the assembler set is full, in which case an error is returned.
-    pub(crate) fn get(
+    pub fn get(
         &mut self,
         key: &K,
         expires_at: Instant,
@@ -240,19 +240,19 @@ impl<K: Eq + Copy> PacketAssemblerSet<K> {
 
 // Max len of non-fragmented packets after decompression (including ipv6 header and payload)
 // TODO: lower. Should be (6lowpan mtu) - (min 6lowpan header size) + (max ipv6 header size)
-pub(crate) const MAX_DECOMPRESSED_LEN: usize = 1500;
+pub const MAX_DECOMPRESSED_LEN: usize = 1500;
 
 #[cfg(feature = "_proto-fragmentation")]
 #[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Clone, Copy)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
-pub(crate) enum FragKey {
+pub enum FragKey {
     #[cfg(feature = "proto-ipv4-fragmentation")]
     Ipv4(Ipv4FragKey),
     #[cfg(feature = "proto-sixlowpan-fragmentation")]
     Sixlowpan(SixlowpanFragKey),
 }
 
-pub(crate) struct FragmentsBuffer {
+pub struct FragmentsBuffer {
     #[cfg(feature = "proto-sixlowpan")]
     pub decompress_buf: [u8; MAX_DECOMPRESSED_LEN],
 
@@ -264,17 +264,17 @@ pub(crate) struct FragmentsBuffer {
 }
 
 #[cfg(not(feature = "_proto-fragmentation"))]
-pub(crate) struct Fragmenter {}
+pub struct Fragmenter {}
 
 #[cfg(not(feature = "_proto-fragmentation"))]
 impl Fragmenter {
-    pub(crate) fn new() -> Self {
+    pub fn new() -> Self {
         Self {}
     }
 }
 
 #[cfg(feature = "_proto-fragmentation")]
-pub(crate) struct Fragmenter {
+pub struct Fragmenter {
     /// The buffer that holds the unfragmented 6LoWPAN packet.
     pub buffer: [u8; FRAGMENTATION_BUFFER_SIZE],
     /// The size of the packet without the IEEE802.15.4 header and the fragmentation headers.
@@ -289,7 +289,7 @@ pub(crate) struct Fragmenter {
 }
 
 #[cfg(feature = "proto-ipv4-fragmentation")]
-pub(crate) struct Ipv4Fragmenter {
+pub struct Ipv4Fragmenter {
     /// The IPv4 representation.
     pub repr: Ipv4Repr,
     /// The destination hardware address.
@@ -302,7 +302,7 @@ pub(crate) struct Ipv4Fragmenter {
 }
 
 #[cfg(feature = "proto-sixlowpan-fragmentation")]
-pub(crate) struct SixlowpanFragmenter {
+pub struct SixlowpanFragmenter {
     /// The datagram size that is used for the fragmentation headers.
     pub datagram_size: u16,
     /// The datagram tag that is used for the fragmentation headers.
@@ -320,7 +320,7 @@ pub(crate) struct SixlowpanFragmenter {
 
 #[cfg(feature = "_proto-fragmentation")]
 impl Fragmenter {
-    pub(crate) fn new() -> Self {
+    pub fn new() -> Self {
         Self {
             buffer: [0u8; FRAGMENTATION_BUFFER_SIZE],
             packet_len: 0,
@@ -355,18 +355,18 @@ impl Fragmenter {
 
     /// Return `true` when everything is transmitted.
     #[inline]
-    pub(crate) fn finished(&self) -> bool {
+    pub fn finished(&self) -> bool {
         self.packet_len == self.sent_bytes
     }
 
     /// Returns `true` when there is nothing to transmit.
     #[inline]
-    pub(crate) fn is_empty(&self) -> bool {
+    pub fn is_empty(&self) -> bool {
         self.packet_len == 0
     }
 
     // Reset the buffer.
-    pub(crate) fn reset(&mut self) {
+    pub fn reset(&mut self) {
         self.packet_len = 0;
         self.sent_bytes = 0;
 
diff --git a/src/iface/interface/ipv4.rs b/src/iface/interface/ipv4.rs
index 7fda3ae..016de6e 100644
--- a/src/iface/interface/ipv4.rs
+++ b/src/iface/interface/ipv4.rs
@@ -41,7 +41,7 @@ impl InterfaceInner {
     /// **NOTE**: unlike for IPv6, no specific selection algorithm is implemented. The first IPv4
     /// address from the interface is returned.
     #[allow(unused)]
-    pub(crate) fn get_source_address_ipv4(&self, _dst_addr: &Ipv4Address) -> Option<Ipv4Address> {
+    pub fn get_source_address_ipv4(&self, _dst_addr: &Ipv4Address) -> Option<Ipv4Address> {
         for cidr in self.ip_addrs.iter() {
             #[allow(irrefutable_let_patterns)] // if only ipv4 is enabled
             if let IpCidr::Ipv4(cidr) = cidr {
@@ -53,7 +53,7 @@ impl InterfaceInner {
 
     /// Checks if an address is broadcast, taking into account ipv4 subnet-local
     /// broadcast addresses.
-    pub(crate) fn is_broadcast_v4(&self, address: Ipv4Address) -> bool {
+    pub fn is_broadcast_v4(&self, address: Ipv4Address) -> bool {
         if address.is_broadcast() {
             return true;
         }
diff --git a/src/iface/interface/ipv6.rs b/src/iface/interface/ipv6.rs
index 96e999f..6445b12 100644
--- a/src/iface/interface/ipv6.rs
+++ b/src/iface/interface/ipv6.rs
@@ -25,7 +25,7 @@ impl InterfaceInner {
     /// # Panics
     /// This function panics if the destination address is unspecified.
     #[allow(unused)]
-    pub(crate) fn get_source_address_ipv6(&self, dst_addr: &Ipv6Address) -> Ipv6Address {
+    pub fn get_source_address_ipv6(&self, dst_addr: &Ipv6Address) -> Ipv6Address {
         assert!(!dst_addr.is_unspecified());
 
         // See RFC 6724 Section 4: Candidate source address
diff --git a/src/iface/interface/mod.rs b/src/iface/interface/mod.rs
index 4df6d73..4570069 100644
--- a/src/iface/interface/mod.rs
+++ b/src/iface/interface/mod.rs
@@ -18,7 +18,7 @@ mod ipv6;
 mod sixlowpan;
 
 #[cfg(feature = "multicast")]
-pub(crate) mod multicast;
+pub mod multicast;
 #[cfg(feature = "socket-tcp")]
 mod tcp;
 #[cfg(any(feature = "socket-udp", feature = "socket-dns"))]
@@ -109,7 +109,7 @@ pub enum PollIngressSingleResult {
 /// a dependency on heap allocation, it instead owns a `BorrowMut<[T]>`, which can be
 /// a `&mut [T]`, or `Vec<T>` if a heap is available.
 pub struct Interface {
-    pub(crate) inner: InterfaceInner,
+    pub inner: InterfaceInner,
     fragments: FragmentsBuffer,
     fragmenter: Fragmenter,
 }
@@ -757,33 +757,33 @@ impl Interface {
 
 impl InterfaceInner {
     #[allow(unused)] // unused depending on which sockets are enabled
-    pub(crate) fn now(&self) -> Instant {
+    pub fn now(&self) -> Instant {
         self.now
     }
 
     #[cfg(any(feature = "medium-ethernet", feature = "medium-ieee802154"))]
     #[allow(unused)] // unused depending on which sockets are enabled
-    pub(crate) fn hardware_addr(&self) -> HardwareAddress {
+    pub fn hardware_addr(&self) -> HardwareAddress {
         self.hardware_addr
     }
 
     #[allow(unused)] // unused depending on which sockets are enabled
-    pub(crate) fn checksum_caps(&self) -> ChecksumCapabilities {
+    pub fn checksum_caps(&self) -> ChecksumCapabilities {
         self.caps.checksum.clone()
     }
 
     #[allow(unused)] // unused depending on which sockets are enabled
-    pub(crate) fn ip_mtu(&self) -> usize {
+    pub fn ip_mtu(&self) -> usize {
         self.caps.ip_mtu()
     }
 
     #[allow(unused)] // unused depending on which sockets are enabled, and in tests
-    pub(crate) fn rand(&mut self) -> &mut Rand {
+    pub fn rand(&mut self) -> &mut Rand {
         &mut self.rand
     }
 
     #[allow(unused)] // unused depending on which sockets are enabled
-    pub(crate) fn get_source_address(&self, dst_addr: &IpAddress) -> Option<IpAddress> {
+    pub fn get_source_address(&self, dst_addr: &IpAddress) -> Option<IpAddress> {
         match dst_addr {
             #[cfg(feature = "proto-ipv4")]
             IpAddress::Ipv4(addr) => self.get_source_address_ipv4(addr).map(|a| a.into()),
@@ -794,7 +794,7 @@ impl InterfaceInner {
 
     #[cfg(test)]
     #[allow(unused)] // unused depending on which sockets are enabled
-    pub(crate) fn set_now(&mut self, now: Instant) {
+    pub fn set_now(&mut self, now: Instant) {
         self.now = now
     }
 
@@ -890,7 +890,7 @@ impl InterfaceInner {
 
     /// Checks if an address is broadcast, taking into account ipv4 subnet-local
     /// broadcast addresses.
-    pub(crate) fn is_broadcast(&self, address: &IpAddress) -> bool {
+    pub fn is_broadcast(&self, address: &IpAddress) -> bool {
         match address {
             #[cfg(feature = "proto-ipv4")]
             IpAddress::Ipv4(address) => self.is_broadcast_v4(*address),
diff --git a/src/iface/interface/multicast.rs b/src/iface/interface/multicast.rs
index 68b1c77..1d31429 100644
--- a/src/iface/interface/multicast.rs
+++ b/src/iface/interface/multicast.rs
@@ -19,7 +19,7 @@ pub enum MulticastError {
 }
 
 #[cfg(feature = "proto-ipv4")]
-pub(crate) enum IgmpReportState {
+pub enum IgmpReportState {
     Inactive,
     ToGeneralQuery {
         version: IgmpVersion,
@@ -44,7 +44,7 @@ enum GroupState {
     Leaving,
 }
 
-pub(crate) struct State {
+pub struct State {
     groups: LinearMap<IpAddress, GroupState, IFACE_MAX_MULTICAST_GROUP_COUNT>,
     /// When to report for (all or) the next multicast group membership via IGMP
     #[cfg(feature = "proto-ipv4")]
@@ -52,7 +52,7 @@ pub(crate) struct State {
 }
 
 impl State {
-    pub(crate) fn new() -> Self {
+    pub fn new() -> Self {
         Self {
             groups: LinearMap::new(),
             #[cfg(feature = "proto-ipv4")]
@@ -60,7 +60,7 @@ impl State {
         }
     }
 
-    pub(crate) fn has_multicast_group<T: Into<IpAddress>>(&self, addr: T) -> bool {
+    pub fn has_multicast_group<T: Into<IpAddress>>(&self, addr: T) -> bool {
         // Return false if we don't have the multicast group,
         // or we're leaving it.
         match self.groups.get(&addr.into()) {
@@ -145,7 +145,7 @@ impl Interface {
     /// - Send join/leave packets according to the multicast group state.
     /// - Depending on `igmp_report_state` and the therein contained
     ///   timeouts, send IGMP membership reports.
-    pub(crate) fn multicast_egress(&mut self, device: &mut (impl Device + ?Sized)) {
+    pub fn multicast_egress(&mut self, device: &mut (impl Device + ?Sized)) {
         // Process multicast joins.
         while let Some((&addr, _)) = self
             .inner
diff --git a/src/iface/interface/sixlowpan.rs b/src/iface/interface/sixlowpan.rs
index d5e3caf..a0cf146 100644
--- a/src/iface/interface/sixlowpan.rs
+++ b/src/iface/interface/sixlowpan.rs
@@ -3,7 +3,7 @@ use crate::wire::Result;
 
 // Max len of non-fragmented packets after decompression (including ipv6 header and payload)
 // TODO: lower. Should be (6lowpan mtu) - (min 6lowpan header size) + (max ipv6 header size)
-pub(crate) const MAX_DECOMPRESSED_LEN: usize = 1500;
+pub const MAX_DECOMPRESSED_LEN: usize = 1500;
 
 impl Interface {
     /// Process fragments that still need to be sent for 6LoWPAN packets.
diff --git a/src/iface/interface/tcp.rs b/src/iface/interface/tcp.rs
index 85fe070..ec3ace3 100644
--- a/src/iface/interface/tcp.rs
+++ b/src/iface/interface/tcp.rs
@@ -3,7 +3,7 @@ use super::*;
 use crate::socket::tcp::Socket;
 
 impl InterfaceInner {
-    pub(crate) fn process_tcp<'frame>(
+    pub fn process_tcp<'frame>(
         &mut self,
         sockets: &mut SocketSet,
         ip_repr: IpRepr,
diff --git a/src/iface/neighbor.rs b/src/iface/neighbor.rs
index dcef2bb..b99db14 100644
--- a/src/iface/neighbor.rs
+++ b/src/iface/neighbor.rs
@@ -21,7 +21,7 @@ pub struct Neighbor {
 /// An answer to a neighbor cache lookup.
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
-pub(crate) enum Answer {
+pub enum Answer {
     /// The neighbor address is in the cache and not expired.
     Found(HardwareAddress),
     /// The neighbor address is not in the cache, or has expired.
@@ -33,7 +33,7 @@ pub(crate) enum Answer {
 
 impl Answer {
     /// Returns whether a valid address was found.
-    pub(crate) fn found(&self) -> bool {
+    pub fn found(&self) -> bool {
         match self {
             Answer::Found(_) => true,
             _ => false,
@@ -50,10 +50,10 @@ pub struct Cache {
 
 impl Cache {
     /// Minimum delay between discovery requests, in milliseconds.
-    pub(crate) const SILENT_TIME: Duration = Duration::from_millis(1_000);
+    pub const SILENT_TIME: Duration = Duration::from_millis(1_000);
 
     /// Neighbor entry lifetime, in milliseconds.
-    pub(crate) const ENTRY_LIFETIME: Duration = Duration::from_millis(60_000);
+    pub const ENTRY_LIFETIME: Duration = Duration::from_millis(60_000);
 
     /// Create a cache.
     pub fn new() -> Self {
@@ -147,7 +147,7 @@ impl Cache {
         }
     }
 
-    pub(crate) fn lookup(&self, protocol_addr: &IpAddress, timestamp: Instant) -> Answer {
+    pub fn lookup(&self, protocol_addr: &IpAddress, timestamp: Instant) -> Answer {
         assert!(protocol_addr.is_unicast());
 
         if let Some(&Neighbor {
@@ -167,11 +167,11 @@ impl Cache {
         }
     }
 
-    pub(crate) fn limit_rate(&mut self, timestamp: Instant) {
+    pub fn limit_rate(&mut self, timestamp: Instant) {
         self.silent_until = timestamp + Self::SILENT_TIME;
     }
 
-    pub(crate) fn flush(&mut self) {
+    pub fn flush(&mut self) {
         self.storage.clear()
     }
 }
diff --git a/src/iface/packet.rs b/src/iface/packet.rs
index 1ccc676..8ed4c9f 100644
--- a/src/iface/packet.rs
+++ b/src/iface/packet.rs
@@ -5,7 +5,7 @@ use crate::wire::*;
 #[derive(Debug, PartialEq)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
 #[cfg(feature = "medium-ethernet")]
-pub(crate) enum EthernetPacket<'a> {
+pub enum EthernetPacket<'a> {
     #[cfg(feature = "proto-ipv4")]
     Arp(ArpRepr),
     Ip(Packet<'a>),
@@ -13,7 +13,7 @@ pub(crate) enum EthernetPacket<'a> {
 
 #[derive(Debug, PartialEq)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
-pub(crate) enum Packet<'p> {
+pub enum Packet<'p> {
     #[cfg(feature = "proto-ipv4")]
     Ipv4(PacketV4<'p>),
     #[cfg(feature = "proto-ipv6")]
@@ -21,7 +21,7 @@ pub(crate) enum Packet<'p> {
 }
 
 impl<'p> Packet<'p> {
-    pub(crate) fn new(ip_repr: IpRepr, payload: IpPayload<'p>) -> Self {
+    pub fn new(ip_repr: IpRepr, payload: IpPayload<'p>) -> Self {
         match ip_repr {
             #[cfg(feature = "proto-ipv4")]
             IpRepr::Ipv4(header) => Self::new_ipv4(header, payload),
@@ -31,7 +31,7 @@ impl<'p> Packet<'p> {
     }
 
     #[cfg(feature = "proto-ipv4")]
-    pub(crate) fn new_ipv4(ip_repr: Ipv4Repr, payload: IpPayload<'p>) -> Self {
+    pub fn new_ipv4(ip_repr: Ipv4Repr, payload: IpPayload<'p>) -> Self {
         Self::Ipv4(PacketV4 {
             header: ip_repr,
             payload,
@@ -39,7 +39,7 @@ impl<'p> Packet<'p> {
     }
 
     #[cfg(feature = "proto-ipv6")]
-    pub(crate) fn new_ipv6(ip_repr: Ipv6Repr, payload: IpPayload<'p>) -> Self {
+    pub fn new_ipv6(ip_repr: Ipv6Repr, payload: IpPayload<'p>) -> Self {
         Self::Ipv6(PacketV6 {
             header: ip_repr,
             #[cfg(feature = "proto-ipv6-hbh")]
@@ -52,7 +52,7 @@ impl<'p> Packet<'p> {
         })
     }
 
-    pub(crate) fn ip_repr(&self) -> IpRepr {
+    pub fn ip_repr(&self) -> IpRepr {
         match self {
             #[cfg(feature = "proto-ipv4")]
             Packet::Ipv4(p) => IpRepr::Ipv4(p.header),
@@ -61,7 +61,7 @@ impl<'p> Packet<'p> {
         }
     }
 
-    pub(crate) fn payload(&self) -> &IpPayload<'p> {
+    pub fn payload(&self) -> &IpPayload<'p> {
         match self {
             #[cfg(feature = "proto-ipv4")]
             Packet::Ipv4(p) => &p.payload,
@@ -70,7 +70,7 @@ impl<'p> Packet<'p> {
         }
     }
 
-    pub(crate) fn emit_payload(
+    pub fn emit_payload(
         &self,
         _ip_repr: &IpRepr,
         payload: &mut [u8],
@@ -183,7 +183,7 @@ impl<'p> Packet<'p> {
 #[derive(Debug, PartialEq)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
 #[cfg(feature = "proto-ipv4")]
-pub(crate) struct PacketV4<'p> {
+pub struct PacketV4<'p> {
     header: Ipv4Repr,
     payload: IpPayload<'p>,
 }
@@ -191,20 +191,20 @@ pub(crate) struct PacketV4<'p> {
 #[derive(Debug, PartialEq)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
 #[cfg(feature = "proto-ipv6")]
-pub(crate) struct PacketV6<'p> {
-    pub(crate) header: Ipv6Repr,
+pub struct PacketV6<'p> {
+    pub header: Ipv6Repr,
     #[cfg(feature = "proto-ipv6-hbh")]
-    pub(crate) hop_by_hop: Option<Ipv6HopByHopRepr<'p>>,
+    pub hop_by_hop: Option<Ipv6HopByHopRepr<'p>>,
     #[cfg(feature = "proto-ipv6-fragmentation")]
-    pub(crate) fragment: Option<Ipv6FragmentRepr>,
+    pub fragment: Option<Ipv6FragmentRepr>,
     #[cfg(feature = "proto-ipv6-routing")]
-    pub(crate) routing: Option<Ipv6RoutingRepr<'p>>,
-    pub(crate) payload: IpPayload<'p>,
+    pub routing: Option<Ipv6RoutingRepr<'p>>,
+    pub payload: IpPayload<'p>,
 }
 
 #[derive(Debug, PartialEq)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
-pub(crate) enum IpPayload<'p> {
+pub enum IpPayload<'p> {
     #[cfg(feature = "proto-ipv4")]
     Icmpv4(Icmpv4Repr<'p>),
     #[cfg(all(feature = "proto-ipv4", feature = "multicast"))]
@@ -225,7 +225,7 @@ pub(crate) enum IpPayload<'p> {
 
 impl<'p> IpPayload<'p> {
     #[cfg(feature = "proto-sixlowpan")]
-    pub(crate) fn as_sixlowpan_next_header(&self) -> SixlowpanNextHeader {
+    pub fn as_sixlowpan_next_header(&self) -> SixlowpanNextHeader {
         match self {
             #[cfg(feature = "proto-ipv4")]
             Self::Icmpv4(_) => unreachable!(),
@@ -248,7 +248,7 @@ impl<'p> IpPayload<'p> {
 }
 
 #[cfg(any(feature = "proto-ipv4", feature = "proto-ipv6"))]
-pub(crate) fn icmp_reply_payload_len(len: usize, mtu: usize, header_len: usize) -> usize {
+pub fn icmp_reply_payload_len(len: usize, mtu: usize, header_len: usize) -> usize {
     // Send back as much of the original payload as will fit within
     // the minimum MTU required by IPv4. See RFC 1812 § 4.3.2.3 for
     // more details.
diff --git a/src/iface/route.rs b/src/iface/route.rs
index f14a57d..7f43d72 100644
--- a/src/iface/route.rs
+++ b/src/iface/route.rs
@@ -146,7 +146,7 @@ impl Routes {
         }
     }
 
-    pub(crate) fn lookup(&self, addr: &IpAddress, timestamp: Instant) -> Option<IpAddress> {
+    pub fn lookup(&self, addr: &IpAddress, timestamp: Instant) -> Option<IpAddress> {
         assert!(addr.is_unicast());
 
         self.storage
diff --git a/src/iface/rpl/of0.rs b/src/iface/rpl/of0.rs
index 299938f..9d75326 100644
--- a/src/iface/rpl/of0.rs
+++ b/src/iface/rpl/of0.rs
@@ -3,7 +3,7 @@ use super::rank::Rank;
 
 pub struct ObjectiveFunction0;
 
-pub(crate) trait ObjectiveFunction {
+pub trait ObjectiveFunction {
     const OCP: u16;
 
     /// Return the new calculated Rank, based on information from the parent.
diff --git a/src/iface/rpl/parents.rs b/src/iface/rpl/parents.rs
index 7d4d60e..ae72151 100644
--- a/src/iface/rpl/parents.rs
+++ b/src/iface/rpl/parents.rs
@@ -4,7 +4,7 @@ use super::{lollipop::SequenceCounter, rank::Rank};
 use crate::config::RPL_PARENTS_BUFFER_COUNT;
 
 #[derive(Debug, Clone, Copy, PartialEq)]
-pub(crate) struct Parent {
+pub struct Parent {
     rank: Rank,
     preference: u8,
     version_number: SequenceCounter,
@@ -13,7 +13,7 @@ pub(crate) struct Parent {
 
 impl Parent {
     /// Create a new parent.
-    pub(crate) fn new(
+    pub fn new(
         preference: u8,
         rank: Rank,
         version_number: SequenceCounter,
@@ -28,20 +28,20 @@ impl Parent {
     }
 
     /// Return the Rank of the parent.
-    pub(crate) fn rank(&self) -> &Rank {
+    pub fn rank(&self) -> &Rank {
         &self.rank
     }
 }
 
 #[derive(Debug, Default)]
-pub(crate) struct ParentSet {
+pub struct ParentSet {
     parents: heapless::LinearMap<Ipv6Address, Parent, { RPL_PARENTS_BUFFER_COUNT }>,
 }
 
 impl ParentSet {
     /// Add a new parent to the parent set. The Rank of the new parent should be lower than the
     /// Rank of the node that holds this parent set.
-    pub(crate) fn add(&mut self, address: Ipv6Address, parent: Parent) {
+    pub fn add(&mut self, address: Ipv6Address, parent: Parent) {
         if let Some(p) = self.parents.get_mut(&address) {
             *p = parent;
         } else if let Err(p) = self.parents.insert(address, parent) {
@@ -59,17 +59,17 @@ impl ParentSet {
     }
 
     /// Find a parent based on its address.
-    pub(crate) fn find(&self, address: &Ipv6Address) -> Option<&Parent> {
+    pub fn find(&self, address: &Ipv6Address) -> Option<&Parent> {
         self.parents.get(address)
     }
 
     /// Find a mutable parent based on its address.
-    pub(crate) fn find_mut(&mut self, address: &Ipv6Address) -> Option<&mut Parent> {
+    pub fn find_mut(&mut self, address: &Ipv6Address) -> Option<&mut Parent> {
         self.parents.get_mut(address)
     }
 
     /// Return a slice to the parent set.
-    pub(crate) fn parents(&self) -> impl Iterator<Item = (&Ipv6Address, &Parent)> {
+    pub fn parents(&self) -> impl Iterator<Item = (&Ipv6Address, &Parent)> {
         self.parents.iter()
     }
 
diff --git a/src/iface/rpl/trickle.rs b/src/iface/rpl/trickle.rs
index a5b3b97..c108f74 100644
--- a/src/iface/rpl/trickle.rs
+++ b/src/iface/rpl/trickle.rs
@@ -16,7 +16,7 @@ use crate::{
 
 #[derive(Debug, PartialEq, Eq)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
-pub(crate) struct TrickleTimer {
+pub struct TrickleTimer {
     i_min: u32,
     i_max: u32,
     k: usize,
@@ -39,7 +39,7 @@ impl TrickleTimer {
     /// don't use the default values from the standard, but the values from the _Enhanced Trickle
     /// Algorithm for Low-Power and Lossy Networks_ from Baraq Ghaleb et al. This is also what the
     /// Contiki Trickle timer does.
-    pub(crate) fn default(now: Instant, rand: &mut Rand) -> Self {
+    pub fn default(now: Instant, rand: &mut Rand) -> Self {
         use super::consts::{
             DEFAULT_DIO_INTERVAL_DOUBLINGS, DEFAULT_DIO_INTERVAL_MIN,
             DEFAULT_DIO_REDUNDANCY_CONSTANT,
@@ -55,7 +55,7 @@ impl TrickleTimer {
     }
 
     /// Create a new Trickle timer.
-    pub(crate) fn new(i_min: u32, i_max: u32, k: usize, now: Instant, rand: &mut Rand) -> Self {
+    pub fn new(i_min: u32, i_max: u32, k: usize, now: Instant, rand: &mut Rand) -> Self {
         let mut timer = Self {
             i_min,
             i_max,
@@ -78,7 +78,7 @@ impl TrickleTimer {
 
     /// Poll the Trickle timer. Returns `true` when the Trickle timer signals that a message can be
     /// transmitted. This happens when the Trickle timer expires.
-    pub(crate) fn poll(&mut self, now: Instant, rand: &mut Rand) -> bool {
+    pub fn poll(&mut self, now: Instant, rand: &mut Rand) -> bool {
         let can_transmit = self.can_transmit() && self.t_expired(now);
 
         if can_transmit {
@@ -94,19 +94,19 @@ impl TrickleTimer {
 
     /// Returns the Instant at which the Trickle timer should be polled again. Polling the Trickle
     /// timer before this Instant is not harmfull, however, polling after it is not correct.
-    pub(crate) fn poll_at(&self) -> Instant {
+    pub fn poll_at(&self) -> Instant {
         self.t_exp.min(self.i_exp)
     }
 
     /// Signal the Trickle timer that a consistency has been heard, and thus increasing it's
     /// counter.
-    pub(crate) fn hear_consistent(&mut self) {
+    pub fn hear_consistent(&mut self) {
         self.counter += 1;
     }
 
     /// Signal the Trickle timer that an inconsistency has been heard. This resets the Trickle
     /// timer when the current interval is not the smallest possible.
-    pub(crate) fn hear_inconsistency(&mut self, now: Instant, rand: &mut Rand) {
+    pub fn hear_inconsistency(&mut self, now: Instant, rand: &mut Rand) {
         let i = Duration::from_millis(2u32.pow(self.i_min) as u64);
         if self.i > i {
             self.reset(i, now, rand);
@@ -115,7 +115,7 @@ impl TrickleTimer {
 
     /// Check if the Trickle timer can transmit or not. Returns `false` when the consistency
     /// counter is bigger or equal to the default consistency constant.
-    pub(crate) fn can_transmit(&self) -> bool {
+    pub fn can_transmit(&self) -> bool {
         self.k != 0 && self.counter < self.k
     }
 
@@ -131,18 +131,18 @@ impl TrickleTimer {
         self.reset(i, now, rand);
     }
 
-    pub(crate) fn reset(&mut self, i: Duration, now: Instant, rand: &mut Rand) {
+    pub fn reset(&mut self, i: Duration, now: Instant, rand: &mut Rand) {
         self.i = i;
         self.i_exp = now + self.i;
         self.counter = 0;
         self.set_t(now, rand);
     }
 
-    pub(crate) const fn max_expiration(&self) -> Duration {
+    pub const fn max_expiration(&self) -> Duration {
         Duration::from_millis(2u32.pow(self.i_max) as u64)
     }
 
-    pub(crate) const fn min_expiration(&self) -> Duration {
+    pub const fn min_expiration(&self) -> Duration {
         Duration::from_millis(2u32.pow(self.i_min) as u64)
     }
 
diff --git a/src/iface/socket_meta.rs b/src/iface/socket_meta.rs
index 82c9908..90926f6 100644
--- a/src/iface/socket_meta.rs
+++ b/src/iface/socket_meta.rs
@@ -30,10 +30,10 @@ enum NeighborState {
 /// itself.
 #[derive(Debug, Default)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
-pub(crate) struct Meta {
+pub struct Meta {
     /// Handle of this socket within its enclosing `SocketSet`.
     /// Mainly useful for debug output.
-    pub(crate) handle: SocketHandle,
+    pub handle: SocketHandle,
     /// See [NeighborState](struct.NeighborState.html).
     neighbor_state: NeighborState,
 }
@@ -43,9 +43,9 @@ impl Meta {
     /// socket, in milliseconds.
     ///
     /// See also `iface::NeighborCache::SILENT_TIME`.
-    pub(crate) const DISCOVERY_SILENT_TIME: Duration = Duration::from_millis(1_000);
+    pub const DISCOVERY_SILENT_TIME: Duration = Duration::from_millis(1_000);
 
-    pub(crate) fn poll_at<F>(&self, socket_poll_at: PollAt, has_neighbor: F) -> PollAt
+    pub fn poll_at<F>(&self, socket_poll_at: PollAt, has_neighbor: F) -> PollAt
     where
         F: Fn(IpAddress) -> bool,
     {
@@ -56,7 +56,7 @@ impl Meta {
         }
     }
 
-    pub(crate) fn egress_permitted<F>(&mut self, timestamp: Instant, has_neighbor: F) -> bool
+    pub fn egress_permitted<F>(&mut self, timestamp: Instant, has_neighbor: F) -> bool
     where
         F: Fn(IpAddress) -> bool,
     {
@@ -88,7 +88,7 @@ impl Meta {
         }
     }
 
-    pub(crate) fn neighbor_missing(&mut self, timestamp: Instant, neighbor: IpAddress) {
+    pub fn neighbor_missing(&mut self, timestamp: Instant, neighbor: IpAddress) {
         net_trace!(
             "{}: neighbor {} missing, silencing until t+{}",
             self.handle,
diff --git a/src/iface/socket_set.rs b/src/iface/socket_set.rs
index be55fef..ddaf1a2 100644
--- a/src/iface/socket_set.rs
+++ b/src/iface/socket_set.rs
@@ -19,9 +19,9 @@ impl<'a> SocketStorage<'a> {
 
 /// An item of a socket set.
 #[derive(Debug)]
-pub(crate) struct Item<'a> {
-    pub(crate) meta: Meta,
-    pub(crate) socket: Socket<'a>,
+pub struct Item<'a> {
+    pub meta: Meta,
+    pub socket: Socket<'a>,
 }
 
 /// A handle, identifying a socket in an Interface.
@@ -140,12 +140,12 @@ impl<'a> SocketSet<'a> {
     }
 
     /// Iterate every socket in this set.
-    pub(crate) fn items(&self) -> impl Iterator<Item = &Item<'a>> + '_ {
+    pub fn items(&self) -> impl Iterator<Item = &Item<'a>> + '_ {
         self.sockets.iter().filter_map(|x| x.inner.as_ref())
     }
 
     /// Iterate every socket in this set.
-    pub(crate) fn items_mut(&mut self) -> impl Iterator<Item = &mut Item<'a>> + '_ {
+    pub fn items_mut(&mut self) -> impl Iterator<Item = &mut Item<'a>> + '_ {
         self.sockets.iter_mut().filter_map(|x| x.inner.as_mut())
     }
 }
diff --git a/src/phy/loopback.rs b/src/phy/loopback.rs
index fd3aea7..07990c4 100644
--- a/src/phy/loopback.rs
+++ b/src/phy/loopback.rs
@@ -8,7 +8,7 @@ use crate::time::Instant;
 /// A loopback device.
 #[derive(Debug)]
 pub struct Loopback {
-    pub(crate) queue: VecDeque<Vec<u8>>,
+    pub queue: VecDeque<Vec<u8>>,
     medium: Medium,
 }
 
diff --git a/src/rand.rs b/src/rand.rs
index 15d88f7..27ad09a 100644
--- a/src/rand.rs
+++ b/src/rand.rs
@@ -2,16 +2,16 @@
 #![allow(unused)]
 
 #[derive(Debug)]
-pub(crate) struct Rand {
+pub struct Rand {
     state: u64,
 }
 
 impl Rand {
-    pub(crate) const fn new(seed: u64) -> Self {
+    pub const fn new(seed: u64) -> Self {
         Self { state: seed }
     }
 
-    pub(crate) fn rand_u32(&mut self) -> u32 {
+    pub fn rand_u32(&mut self) -> u32 {
         // sPCG32 from https://www.pcg-random.org/paper.html
         // see also https://nullprogram.com/blog/2017/09/21/
         const M: u64 = 0xbb2efcec3c39611d;
@@ -24,12 +24,12 @@ impl Rand {
         (s >> shift) as u32
     }
 
-    pub(crate) fn rand_u16(&mut self) -> u16 {
+    pub fn rand_u16(&mut self) -> u16 {
         let n = self.rand_u32();
         (n ^ (n >> 16)) as u16
     }
 
-    pub(crate) fn rand_source_port(&mut self) -> u16 {
+    pub fn rand_source_port(&mut self) -> u16 {
         loop {
             let res = self.rand_u16();
             if res > 1024 {
diff --git a/src/socket/dhcpv4.rs b/src/socket/dhcpv4.rs
index 72980a9..31beed8 100644
--- a/src/socket/dhcpv4.rs
+++ b/src/socket/dhcpv4.rs
@@ -169,10 +169,10 @@ pub struct Socket<'a> {
     ignore_naks: bool,
 
     /// Server port config
-    pub(crate) server_port: u16,
+    pub server_port: u16,
 
     /// Client port config
-    pub(crate) client_port: u16,
+    pub client_port: u16,
 
     /// A buffer contains options additional to be added to outgoing DHCP
     /// packets.
@@ -288,7 +288,7 @@ impl<'a> Socket<'a> {
         self.client_port = client_port;
     }
 
-    pub(crate) fn poll_at(&self, _cx: &mut Context) -> PollAt {
+    pub fn poll_at(&self, _cx: &mut Context) -> PollAt {
         let t = match &self.state {
             ClientState::Discovering(state) => state.retry_at,
             ClientState::Requesting(state) => state.retry_at,
@@ -302,7 +302,7 @@ impl<'a> Socket<'a> {
         PollAt::Time(t)
     }
 
-    pub(crate) fn process(
+    pub fn process(
         &mut self,
         cx: &mut Context,
         ip_repr: &Ipv4Repr,
@@ -548,7 +548,7 @@ impl<'a> Socket<'a> {
         0x12345678
     }
 
-    pub(crate) fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
+    pub fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
     where
         F: FnOnce(&mut Context, (Ipv4Repr, UdpRepr, DhcpRepr)) -> Result<(), E>,
     {
@@ -754,7 +754,7 @@ impl<'a> Socket<'a> {
     /// This function _must_ be called when the configuration provided to the
     /// interface, by this DHCP socket, changes. It will update the `config_changed` field
     /// so that a subsequent call to `poll` will yield an event, and wake a possible waker.
-    pub(crate) fn config_changed(&mut self) {
+    pub fn config_changed(&mut self) {
         self.config_changed = true;
         #[cfg(feature = "async")]
         self.waker.wake();
diff --git a/src/socket/dns.rs b/src/socket/dns.rs
index 681cf10..9e034c2 100644
--- a/src/socket/dns.rs
+++ b/src/socket/dns.rs
@@ -368,7 +368,7 @@ impl<'a> Socket<'a> {
             .register(waker);
     }
 
-    pub(crate) fn accepts(&self, ip_repr: &IpRepr, udp_repr: &UdpRepr) -> bool {
+    pub fn accepts(&self, ip_repr: &IpRepr, udp_repr: &UdpRepr) -> bool {
         (udp_repr.src_port == DNS_PORT
             && self
                 .servers
@@ -377,7 +377,7 @@ impl<'a> Socket<'a> {
             || (udp_repr.src_port == MDNS_DNS_PORT)
     }
 
-    pub(crate) fn process(
+    pub fn process(
         &mut self,
         _cx: &mut Context,
         ip_repr: &IpRepr,
@@ -531,7 +531,7 @@ impl<'a> Socket<'a> {
         net_trace!("no query matched");
     }
 
-    pub(crate) fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
+    pub fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
     where
         F: FnOnce(&mut Context, (IpRepr, UdpRepr, &[u8])) -> Result<(), E>,
     {
@@ -653,7 +653,7 @@ impl<'a> Socket<'a> {
         Ok(())
     }
 
-    pub(crate) fn poll_at(&self, _cx: &Context) -> PollAt {
+    pub fn poll_at(&self, _cx: &Context) -> PollAt {
         self.queries
             .iter()
             .flatten()
diff --git a/src/socket/icmp.rs b/src/socket/icmp.rs
index dee3416..091e07d 100644
--- a/src/socket/icmp.rs
+++ b/src/socket/icmp.rs
@@ -426,7 +426,7 @@ impl<'a> Socket<'a> {
     /// Accepted packets are enqueued into the socket's receive buffer.
     #[cfg(feature = "proto-ipv4")]
     #[inline]
-    pub(crate) fn accepts_v4(
+    pub fn accepts_v4(
         &self,
         cx: &mut Context,
         ip_repr: &Ipv4Repr,
@@ -468,7 +468,7 @@ impl<'a> Socket<'a> {
     /// Accepted packets are enqueued into the socket's receive buffer.
     #[cfg(feature = "proto-ipv6")]
     #[inline]
-    pub(crate) fn accepts_v6(
+    pub fn accepts_v6(
         &self,
         cx: &mut Context,
         ip_repr: &Ipv6Repr,
@@ -507,7 +507,7 @@ impl<'a> Socket<'a> {
     }
 
     #[cfg(feature = "proto-ipv4")]
-    pub(crate) fn process_v4(
+    pub fn process_v4(
         &mut self,
         _cx: &mut Context,
         ip_repr: &Ipv4Repr,
@@ -533,7 +533,7 @@ impl<'a> Socket<'a> {
     }
 
     #[cfg(feature = "proto-ipv6")]
-    pub(crate) fn process_v6(
+    pub fn process_v6(
         &mut self,
         _cx: &mut Context,
         ip_repr: &Ipv6Repr,
@@ -558,7 +558,7 @@ impl<'a> Socket<'a> {
         self.rx_waker.wake();
     }
 
-    pub(crate) fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
+    pub fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
     where
         F: FnOnce(&mut Context, (IpRepr, IcmpRepr)) -> Result<(), E>,
     {
@@ -644,7 +644,7 @@ impl<'a> Socket<'a> {
         }
     }
 
-    pub(crate) fn poll_at(&self, _cx: &mut Context) -> PollAt {
+    pub fn poll_at(&self, _cx: &mut Context) -> PollAt {
         if self.tx_buffer.is_empty() {
             PollAt::Ingress
         } else {
diff --git a/src/socket/mod.rs b/src/socket/mod.rs
index 7d48b42..9681f08 100644
--- a/src/socket/mod.rs
+++ b/src/socket/mod.rs
@@ -31,12 +31,12 @@ pub mod udp;
 mod waker;
 
 #[cfg(feature = "async")]
-pub(crate) use self::waker::WakerRegistration;
+pub use self::waker::WakerRegistration;
 
 /// Gives an indication on the next time the socket should be polled.
 #[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Clone, Copy)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
-pub(crate) enum PollAt {
+pub enum PollAt {
     /// The socket needs to be polled immediately.
     Now,
     /// The socket needs to be polled at given [Instant][struct.Instant].
@@ -72,7 +72,7 @@ pub enum Socket<'a> {
 }
 
 impl<'a> Socket<'a> {
-    pub(crate) fn poll_at(&self, cx: &mut Context) -> PollAt {
+    pub fn poll_at(&self, cx: &mut Context) -> PollAt {
         match self {
             #[cfg(feature = "socket-raw")]
             Socket::Raw(s) => s.poll_at(cx),
diff --git a/src/socket/raw.rs b/src/socket/raw.rs
index c79f99b..cb655af 100644
--- a/src/socket/raw.rs
+++ b/src/socket/raw.rs
@@ -337,7 +337,7 @@ impl<'a> Socket<'a> {
         self.rx_buffer.payload_bytes_count()
     }
 
-    pub(crate) fn accepts(&self, ip_repr: &IpRepr) -> bool {
+    pub fn accepts(&self, ip_repr: &IpRepr) -> bool {
         if ip_repr.version() != self.ip_version {
             return false;
         }
@@ -348,7 +348,7 @@ impl<'a> Socket<'a> {
         true
     }
 
-    pub(crate) fn process(&mut self, cx: &mut Context, ip_repr: &IpRepr, payload: &[u8]) {
+    pub fn process(&mut self, cx: &mut Context, ip_repr: &IpRepr, payload: &[u8]) {
         debug_assert!(self.accepts(ip_repr));
 
         let header_len = ip_repr.header_len();
@@ -377,7 +377,7 @@ impl<'a> Socket<'a> {
         self.rx_waker.wake();
     }
 
-    pub(crate) fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
+    pub fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
     where
         F: FnOnce(&mut Context, (IpRepr, &[u8])) -> Result<(), E>,
     {
@@ -460,7 +460,7 @@ impl<'a> Socket<'a> {
         }
     }
 
-    pub(crate) fn poll_at(&self, _cx: &mut Context) -> PollAt {
+    pub fn poll_at(&self, _cx: &mut Context) -> PollAt {
         if self.tx_buffer.is_empty() {
             PollAt::Ingress
         } else {
diff --git a/src/socket/tcp.rs b/src/socket/tcp.rs
index d50631d..5a80ad3 100644
--- a/src/socket/tcp.rs
+++ b/src/socket/tcp.rs
@@ -1329,7 +1329,7 @@ impl<'a> Socket<'a> {
         }
     }
 
-    pub(crate) fn reply(ip_repr: &IpRepr, repr: &TcpRepr) -> (IpRepr, TcpRepr<'static>) {
+    pub fn reply(ip_repr: &IpRepr, repr: &TcpRepr) -> (IpRepr, TcpRepr<'static>) {
         let reply_repr = TcpRepr {
             src_port: repr.dst_port,
             dst_port: repr.src_port,
@@ -1354,7 +1354,7 @@ impl<'a> Socket<'a> {
         (ip_reply_repr, reply_repr)
     }
 
-    pub(crate) fn rst_reply(ip_repr: &IpRepr, repr: &TcpRepr) -> (IpRepr, TcpRepr<'static>) {
+    pub fn rst_reply(ip_repr: &IpRepr, repr: &TcpRepr) -> (IpRepr, TcpRepr<'static>) {
         debug_assert!(repr.control != TcpControl::Rst);
 
         let (ip_reply_repr, mut reply_repr) = Self::reply(ip_repr, repr);
@@ -1446,7 +1446,7 @@ impl<'a> Socket<'a> {
         Some(self.ack_reply(ip_repr, repr))
     }
 
-    pub(crate) fn accepts(&self, _cx: &mut Context, ip_repr: &IpRepr, repr: &TcpRepr) -> bool {
+    pub fn accepts(&self, _cx: &mut Context, ip_repr: &IpRepr, repr: &TcpRepr) -> bool {
         if self.state == State::Closed {
             return false;
         }
@@ -1474,7 +1474,7 @@ impl<'a> Socket<'a> {
         }
     }
 
-    pub(crate) fn process(
+    pub fn process(
         &mut self,
         cx: &mut Context,
         ip_repr: &IpRepr,
@@ -2247,7 +2247,7 @@ impl<'a> Socket<'a> {
         }
     }
 
-    pub(crate) fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
+    pub fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
     where
         F: FnOnce(&mut Context, (IpRepr, TcpRepr)) -> Result<(), E>,
     {
@@ -2549,7 +2549,7 @@ impl<'a> Socket<'a> {
     }
 
     #[allow(clippy::if_same_then_else)]
-    pub(crate) fn poll_at(&self, cx: &mut Context) -> PollAt {
+    pub fn poll_at(&self, cx: &mut Context) -> PollAt {
         // The logic here mirrors the beginning of dispatch() closely.
         if self.tuple.is_none() {
             // No one to talk to, nothing to transmit.
diff --git a/src/socket/udp.rs b/src/socket/udp.rs
index 1e09116..1b1f9a1 100644
--- a/src/socket/udp.rs
+++ b/src/socket/udp.rs
@@ -475,7 +475,7 @@ impl<'a> Socket<'a> {
         self.rx_buffer.payload_bytes_count()
     }
 
-    pub(crate) fn accepts(&self, cx: &mut Context, ip_repr: &IpRepr, repr: &UdpRepr) -> bool {
+    pub fn accepts(&self, cx: &mut Context, ip_repr: &IpRepr, repr: &UdpRepr) -> bool {
         if self.endpoint.port != repr.dst_port {
             return false;
         }
@@ -490,7 +490,7 @@ impl<'a> Socket<'a> {
         true
     }
 
-    pub(crate) fn process(
+    pub fn process(
         &mut self,
         cx: &mut Context,
         meta: PacketMeta,
@@ -533,7 +533,7 @@ impl<'a> Socket<'a> {
         self.rx_waker.wake();
     }
 
-    pub(crate) fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
+    pub fn dispatch<F, E>(&mut self, cx: &mut Context, emit: F) -> Result<(), E>
     where
         F: FnOnce(&mut Context, PacketMeta, (IpRepr, UdpRepr, &[u8])) -> Result<(), E>,
     {
@@ -592,7 +592,7 @@ impl<'a> Socket<'a> {
         }
     }
 
-    pub(crate) fn poll_at(&self, _cx: &mut Context) -> PollAt {
+    pub fn poll_at(&self, _cx: &mut Context) -> PollAt {
         if self.tx_buffer.is_empty() {
             PollAt::Ingress
         } else {
diff --git a/src/storage/packet_buffer.rs b/src/storage/packet_buffer.rs
index f9121e6..339916c 100644
--- a/src/storage/packet_buffer.rs
+++ b/src/storage/packet_buffer.rs
@@ -246,7 +246,7 @@ impl<'a, H> PacketBuffer<'a, H> {
 
     /// Reset the packet buffer and clear any staged.
     #[allow(unused)]
-    pub(crate) fn reset(&mut self) {
+    pub fn reset(&mut self) {
         self.payload_ring.clear();
         self.metadata_ring.clear();
     }
diff --git a/src/tests.rs b/src/tests.rs
index 165bd52..dffc678 100644
--- a/src/tests.rs
+++ b/src/tests.rs
@@ -5,7 +5,7 @@ use crate::phy::{self, Device, DeviceCapabilities, Medium};
 use crate::time::Instant;
 use crate::wire::*;
 
-pub(crate) fn setup<'a>(medium: Medium) -> (Interface, SocketSet<'a>, TestingDevice) {
+pub fn setup<'a>(medium: Medium) -> (Interface, SocketSet<'a>, TestingDevice) {
     let mut device = TestingDevice::new(medium);
 
     let config = Config::new(match medium {
@@ -56,8 +56,8 @@ pub(crate) fn setup<'a>(medium: Medium) -> (Interface, SocketSet<'a>, TestingDev
 /// A testing device.
 #[derive(Debug)]
 pub struct TestingDevice {
-    pub(crate) tx_queue: VecDeque<Vec<u8>>,
-    pub(crate) rx_queue: VecDeque<Vec<u8>>,
+    pub tx_queue: VecDeque<Vec<u8>>,
+    pub rx_queue: VecDeque<Vec<u8>>,
     max_transmission_unit: usize,
     medium: Medium,
 }
diff --git a/src/wire/dhcpv4.rs b/src/wire/dhcpv4.rs
index 87ace13..0f2c634 100644
--- a/src/wire/dhcpv4.rs
+++ b/src/wire/dhcpv4.rs
@@ -117,7 +117,7 @@ pub struct Packet<T: AsRef<[u8]>> {
     buffer: T,
 }
 
-pub(crate) mod field {
+pub mod field {
     #![allow(non_snake_case)]
     #![allow(unused)]
 
diff --git a/src/wire/ip.rs b/src/wire/ip.rs
index e61541c..b8cd0f4 100644
--- a/src/wire/ip.rs
+++ b/src/wire/ip.rs
@@ -779,7 +779,7 @@ pub mod checksum {
     }
 
     // We use this in pretty printer implementations.
-    pub(crate) fn format_checksum(f: &mut fmt::Formatter, correct: bool) -> fmt::Result {
+    pub fn format_checksum(f: &mut fmt::Formatter, correct: bool) -> fmt::Result {
         if !correct {
             write!(f, " (checksum incorrect)")
         } else {
@@ -866,7 +866,7 @@ pub fn pretty_print_ip_payload<T: Into<Repr>>(
 }
 
 #[cfg(test)]
-pub(crate) mod test {
+pub mod test {
     #![allow(unused)]
 
     use super::*;
diff --git a/src/wire/ipv4.rs b/src/wire/ipv4.rs
index 7629a46..6ed9699 100644
--- a/src/wire/ipv4.rs
+++ b/src/wire/ipv4.rs
@@ -43,7 +43,7 @@ pub struct Key {
 
 pub use core::net::Ipv4Addr as Address;
 
-pub(crate) trait AddressExt {
+pub trait AddressExt {
     /// Construct an IPv4 address from a sequence of octets, in big-endian.
     ///
     /// # Panics
@@ -717,19 +717,19 @@ impl<T: AsRef<[u8]>> PrettyPrint for Packet<T> {
 }
 
 #[cfg(test)]
-pub(crate) mod test {
+pub mod test {
     use super::*;
 
     #[allow(unused)]
-    pub(crate) const MOCK_IP_ADDR_1: Address = Address::new(192, 168, 1, 1);
+    pub const MOCK_IP_ADDR_1: Address = Address::new(192, 168, 1, 1);
     #[allow(unused)]
-    pub(crate) const MOCK_IP_ADDR_2: Address = Address::new(192, 168, 1, 2);
+    pub const MOCK_IP_ADDR_2: Address = Address::new(192, 168, 1, 2);
     #[allow(unused)]
-    pub(crate) const MOCK_IP_ADDR_3: Address = Address::new(192, 168, 1, 3);
+    pub const MOCK_IP_ADDR_3: Address = Address::new(192, 168, 1, 3);
     #[allow(unused)]
-    pub(crate) const MOCK_IP_ADDR_4: Address = Address::new(192, 168, 1, 4);
+    pub const MOCK_IP_ADDR_4: Address = Address::new(192, 168, 1, 4);
     #[allow(unused)]
-    pub(crate) const MOCK_UNSPECIFIED: Address = Address::UNSPECIFIED;
+    pub const MOCK_UNSPECIFIED: Address = Address::UNSPECIFIED;
 
     static PACKET_BYTES: [u8; 30] = [
         0x45, 0x00, 0x00, 0x1e, 0x01, 0x02, 0x62, 0x03, 0x1a, 0x01, 0xd5, 0x6e, 0x11, 0x12, 0x13,
diff --git a/src/wire/ipv6.rs b/src/wire/ipv6.rs
index 8dc05c5..b454842 100644
--- a/src/wire/ipv6.rs
+++ b/src/wire/ipv6.rs
@@ -43,7 +43,7 @@ pub const LINK_LOCAL_ALL_RPL_NODES: Address = Address::new(0xff02, 0, 0, 0, 0, 0
 /// [scope]: https://www.rfc-editor.org/rfc/rfc4291#section-2.7
 #[repr(u8)]
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub(crate) enum MulticastScope {
+pub enum MulticastScope {
     /// Interface Local scope
     InterfaceLocal = 0x1,
     /// Link local scope
@@ -76,7 +76,7 @@ impl From<u8> for MulticastScope {
 
 pub use core::net::Ipv6Addr as Address;
 
-pub(crate) trait AddressExt {
+pub trait AddressExt {
     /// Construct an IPv6 address from a sequence of octets, in big-endian.
     ///
     /// # Panics
@@ -661,20 +661,20 @@ impl<T: AsRef<[u8]>> PrettyPrint for Packet<T> {
 }
 
 #[cfg(test)]
-pub(crate) mod test {
+pub mod test {
     use super::*;
     use crate::wire::pretty_print::PrettyPrinter;
 
     #[allow(unused)]
-    pub(crate) const MOCK_IP_ADDR_1: Address = Address::new(0xfe80, 0, 0, 0, 0, 0, 0, 1);
+    pub const MOCK_IP_ADDR_1: Address = Address::new(0xfe80, 0, 0, 0, 0, 0, 0, 1);
     #[allow(unused)]
-    pub(crate) const MOCK_IP_ADDR_2: Address = Address::new(0xfe80, 0, 0, 0, 0, 0, 0, 2);
+    pub const MOCK_IP_ADDR_2: Address = Address::new(0xfe80, 0, 0, 0, 0, 0, 0, 2);
     #[allow(unused)]
-    pub(crate) const MOCK_IP_ADDR_3: Address = Address::new(0xfe80, 0, 0, 0, 0, 0, 0, 3);
+    pub const MOCK_IP_ADDR_3: Address = Address::new(0xfe80, 0, 0, 0, 0, 0, 0, 3);
     #[allow(unused)]
-    pub(crate) const MOCK_IP_ADDR_4: Address = Address::new(0xfe80, 0, 0, 0, 0, 0, 0, 4);
+    pub const MOCK_IP_ADDR_4: Address = Address::new(0xfe80, 0, 0, 0, 0, 0, 0, 4);
     #[allow(unused)]
-    pub(crate) const MOCK_UNSPECIFIED: Address = Address::UNSPECIFIED;
+    pub const MOCK_UNSPECIFIED: Address = Address::UNSPECIFIED;
 
     const LINK_LOCAL_ADDR: Address = Address::new(0xfe80, 0, 0, 0, 0, 0, 0, 1);
     const UNIQUE_LOCAL_ADDR: Address = Address::new(0xfd00, 0, 0, 201, 1, 1, 1, 1);
diff --git a/src/wire/mod.rs b/src/wire/mod.rs
index a6db11c..bb3ad22 100644
--- a/src/wire/mod.rs
+++ b/src/wire/mod.rs
@@ -80,9 +80,9 @@ pub mod pretty_print;
 #[cfg(all(feature = "proto-ipv4", feature = "medium-ethernet"))]
 mod arp;
 #[cfg(feature = "proto-dhcpv4")]
-pub(crate) mod dhcpv4;
+pub mod dhcpv4;
 #[cfg(feature = "proto-dns")]
-pub(crate) mod dns;
+pub mod dns;
 #[cfg(feature = "medium-ethernet")]
 mod ethernet;
 #[cfg(any(feature = "proto-ipv4", feature = "proto-ipv6"))]
@@ -95,11 +95,11 @@ mod icmpv6;
 pub mod ieee802154;
 #[cfg(feature = "proto-ipv4")]
 mod igmp;
-pub(crate) mod ip;
+pub mod ip;
 #[cfg(feature = "proto-ipv4")]
-pub(crate) mod ipv4;
+pub mod ipv4;
 #[cfg(feature = "proto-ipv6")]
-pub(crate) mod ipv6;
+pub mod ipv6;
 #[cfg(feature = "proto-ipv6")]
 mod ipv6ext_header;
 #[cfg(feature = "proto-ipv6")]
@@ -193,7 +193,7 @@ pub use self::ipv4::{
 };
 
 #[cfg(feature = "proto-ipv4")]
-pub(crate) use self::ipv4::AddressExt as Ipv4AddressExt;
+pub use self::ipv4::AddressExt as Ipv4AddressExt;
 
 #[cfg(feature = "proto-ipv6")]
 pub use self::ipv6::{
@@ -205,7 +205,7 @@ pub use self::ipv6::{
     LINK_LOCAL_ALL_RPL_NODES as IPV6_LINK_LOCAL_ALL_RPL_NODES, MIN_MTU as IPV6_MIN_MTU,
 };
 #[cfg(feature = "proto-ipv6")]
-pub(crate) use self::ipv6::{AddressExt as Ipv6AddressExt, MulticastScope as Ipv6MulticastScope};
+pub use self::ipv6::{AddressExt as Ipv6AddressExt, MulticastScope as Ipv6MulticastScope};
 
 #[cfg(feature = "proto-ipv6")]
 pub use self::ipv6option::{
@@ -398,7 +398,7 @@ impl HardwareAddress {
     }
 
     #[cfg(feature = "medium-ethernet")]
-    pub(crate) fn ethernet_or_panic(&self) -> EthernetAddress {
+    pub fn ethernet_or_panic(&self) -> EthernetAddress {
         match self {
             HardwareAddress::Ethernet(addr) => *addr,
             #[allow(unreachable_patterns)]
@@ -407,7 +407,7 @@ impl HardwareAddress {
     }
 
     #[cfg(feature = "medium-ieee802154")]
-    pub(crate) fn ieee802154_or_panic(&self) -> Ieee802154Address {
+    pub fn ieee802154_or_panic(&self) -> Ieee802154Address {
         match self {
             HardwareAddress::Ieee802154(addr) => *addr,
             #[allow(unreachable_patterns)]
@@ -416,7 +416,7 @@ impl HardwareAddress {
     }
 
     #[inline]
-    pub(crate) fn medium(&self) -> Medium {
+    pub fn medium(&self) -> Medium {
         match self {
             #[cfg(feature = "medium-ip")]
             HardwareAddress::Ip => Medium::Ip,
diff --git a/src/wire/sixlowpan/frag.rs b/src/wire/sixlowpan/frag.rs
index eed7f05..4eaf9b2 100644
--- a/src/wire/sixlowpan/frag.rs
+++ b/src/wire/sixlowpan/frag.rs
@@ -11,10 +11,10 @@ use byteorder::{ByteOrder, NetworkEndian};
 #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(feature = "defmt", derive(defmt::Format))]
 pub struct Key {
-    pub(crate) ll_src_addr: Ieee802154Address,
-    pub(crate) ll_dst_addr: Ieee802154Address,
-    pub(crate) datagram_size: u16,
-    pub(crate) datagram_tag: u16,
+    pub ll_src_addr: Ieee802154Address,
+    pub ll_dst_addr: Ieee802154Address,
+    pub datagram_size: u16,
+    pub datagram_tag: u16,
 }
 
 /// A read/write wrapper around a 6LoWPAN Fragment header.
diff --git a/src/wire/sixlowpan/nhc.rs b/src/wire/sixlowpan/nhc.rs
index d558d1d..52458b2 100644
--- a/src/wire/sixlowpan/nhc.rs
+++ b/src/wire/sixlowpan/nhc.rs
@@ -591,7 +591,7 @@ impl<T: AsRef<[u8]>> UdpNhcPacket<T> {
     }
 
     // Return the size of the checksum field.
-    pub(crate) fn checksum_size(&self) -> usize {
+    pub fn checksum_size(&self) -> usize {
         match self.checksum_field() {
             0b0 => 2,
             0b1 => 0,
@@ -600,7 +600,7 @@ impl<T: AsRef<[u8]>> UdpNhcPacket<T> {
     }
 
     /// Returns the total size of both port numbers.
-    pub(crate) fn ports_size(&self) -> usize {
+    pub fn ports_size(&self) -> usize {
         match self.ports_field() {
             0b00 => 4, // 16 bits + 16 bits
             0b01 => 3, // 16 bits + 8 bits
diff --git a/src/wire/udp.rs b/src/wire/udp.rs
index 9d341e0..78b460f 100644
--- a/src/wire/udp.rs
+++ b/src/wire/udp.rs
@@ -255,7 +255,7 @@ impl Repr {
     /// This never calculates the checksum, and is intended for internal-use only,
     /// not for packets that are going to be actually sent over the network. For
     /// example, when decompressing 6lowpan.
-    pub(crate) fn emit_header<T>(&self, packet: &mut Packet<&mut T>, payload_len: usize)
+    pub fn emit_header<T>(&self, packet: &mut Packet<&mut T>, payload_len: usize)
     where
         T: AsRef<[u8]> + AsMut<[u8]> + ?Sized,
     {
-- 
2.47.0

